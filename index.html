<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3D Island Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle, #87CEEB 0%, #4682B4 100%); touch-action: none; }
        canvas { display: block; }

        /* Джойстик */
        #joystick-base {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none; /* З'являється при дотику */
            z-index: 10;
        }
        #joystick-stick {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 30px;
            left: 30px;
        }

        #ui-hint {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-hint">Зліва — рух | Справа — огляд</div>
    <div id="joystick-base"><div id="joystick-stick"></div></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- НАЛАШТУВАННЯ СЦЕНИ ТА ГРАФІКИ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Обмежуємо для швидкості
        renderer.shadowMap.enabled = true; // Вмикаємо тіні
        document.body.appendChild(renderer.domElement);

        // Світло
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(10, 20, 15);
        sun.castShadow = true;
        scene.add(sun);

        // --- ОБ'ЄКТИ ---
        // Острів
        const islandGeo = new THREE.CylinderGeometry(20, 22, 2, 64);
        const islandMat = new THREE.MeshStandardMaterial({ 
            color: 0xedc9af, 
            roughness: 0.8,
            metalness: 0.1
        });
        const island = new THREE.Mesh(islandGeo, islandMat);
        island.position.y = -1;
        island.receiveShadow = true;
        scene.add(island);

        // Океан з анімацією
        const waterGeo = new THREE.CircleGeometry(200, 32);
        const waterMat = new THREE.MeshStandardMaterial({ 
            color: 0x0077be, 
            transparent: true, 
            opacity: 0.6,
            roughness: 0
        });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -1.05;
        scene.add(water);

        // Храм
        const buildGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 8), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        body.castShadow = true;
        body.receiveShadow = true;
        buildGroup.add(body);

        // Смуги
        for(let i=0; i<3; i++) {
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(8.1, 0.5, 8.1), new THREE.MeshStandardMaterial({ color: 0x0033aa }));
            stripe.position.y = -1.5 + (i * 1.5);
            buildGroup.add(stripe);
        }
        buildGroup.position.y = 2;
        scene.add(buildGroup);

        // --- КЕРУВАННЯ (Двома пальцями) ---
        let moveData = { x: 0, y: 0, active: false };
        let lookData = { x: 0, y: 0 };
        let rotation = { yaw: 0, pitch: 0 };

        const joyBase = document.getElementById('joystick-base');
        const joyStick = document.getElementById('joystick-stick');

        window.addEventListener('touchstart', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.clientX < window.innerWidth / 2) {
                    // Ліва частина - джойстик
                    moveData.active = true;
                    moveData.id = touch.identifier;
                    joyBase.style.display = 'block';
                    joyBase.style.left = `${touch.clientX - 50}px`;
                    joyBase.style.top = `${touch.clientY - 50}px`;
                    moveData.startX = touch.clientX;
                    moveData.startY = touch.clientY;
                }
            }
        });

        window.addEventListener('touchmove', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === moveData.id) {
                    // Оновлення джойстика
                    let dx = touch.clientX - moveData.startX;
                    let dy = touch.clientY - moveData.startY;
                    const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
                    const angle = Math.atan2(dy, dx);
                    
                    moveData.x = (Math.cos(angle) * dist) / 40;
                    moveData.y = (Math.sin(angle) * dist) / 40;
                    
                    joyStick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
                } else {
                    // Права частина - огляд
                    rotation.yaw -= (touch.clientX - (lookData.lastX || touch.clientX)) * 0.005;
                    rotation.pitch -= (touch.clientY - (lookData.lastY || touch.clientY)) * 0.005;
                    rotation.pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, rotation.pitch));
                    
                    lookData.lastX = touch.clientX;
                    lookData.lastY = touch.clientY;
                }
            }
        });

        window.addEventListener('touchend', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === moveData.id) {
                    moveData.active = false;
                    moveData.x = 0; moveData.y = 0;
                    joyBase.style.display = 'none';
                } else {
                    lookData.lastX = null; lookData.lastY = null;
                }
            }
        });

        // --- ЦИКЛ ГРИ ---
        const velocity = new THREE.Vector3();
        
        function update() {
            requestAnimationFrame(update);

            // Рух
            if (moveData.active) {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                right.y = 0; right.normalize();

                const oldPos = camera.position.clone();
                camera.position.addScaledVector(forward, -moveData.y * 0.12);
                camera.position.addScaledVector(right, moveData.x * 0.12);

                // Колізія з будівлею (спрощена)
                if (Math.abs(camera.position.x) < 5 && Math.abs(camera.position.z) < 5) {
                    camera.position.copy(oldPos);
                }
                // Межі острова
                if (camera.position.length() > 19) camera.position.copy(oldPos);
            }

            // Огляд
            camera.rotation.order = 'YXZ';
            camera.rotation.y = rotation.yaw;
            camera.rotation.x = rotation.pitch;

            // Хвилі (графічний ефект)
            water.position.y = -1.05 + Math.sin(Date.now() * 0.001) * 0.02;

            renderer.render(scene, camera);
        }

        update();

        // Ресайз
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
