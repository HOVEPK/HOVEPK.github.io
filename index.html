<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>St. James Island: Browser Pro Edition</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; cursor: crosshair; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: white; pointer-events: none; text-shadow: 2px 2px 8px #000; z-index: 10; opacity: 0.8; letter-spacing: 2px; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #joystick { position: absolute; bottom: 40px; left: 40px; width: 100px; height: 100px; border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; display: none; } /* Для мобилок */
    </style>
</head>
<body>

<div id="ui">КЛИКНИТЕ, ЧТОБЫ ВОЙТИ В РЕЖИМ 1-ГО ЛИЦА</div>
<div id="crosshair"></div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';

    let scene, camera, renderer, controls, water, clock;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    const colliders = [];

    init();

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x001e0f, 0.005); // Туман для реализма
        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(60, 5, 60);

        renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Управление как в играх (Pointer Lock)
        controls = new PointerLockControls(camera, document.body);
        document.body.addEventListener('click', () => {
            controls.lock();
            document.getElementById('ui').innerHTML = "WASD - ДВИЖЕНИЕ | МЫШЬ - ОБЗОР";
        });

        setupEnvironment();
        createRealisticIsland();
        setupInput();

        window.addEventListener('resize', onWindowResize);
        animate();
    }

    function setupEnvironment() {
        const sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);
        const sun = new THREE.Vector3();
        sun.setFromSphericalCoords(1, Math.PI / 2.05, Math.PI);
        sky.material.uniforms['sunPosition'].value.copy(sun);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(50, 100, 50);
        scene.add(light);

        water = new Water(new THREE.PlaneGeometry(5000, 5000), {
            textureWidth: 1024, textureHeight: 1024,
            waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', t => t.wrapS = t.wrapT = THREE.RepeatWrapping),
            sunDirection: sun, sunColor: 0xffffff, waterColor: 0x001e0f, distortionScale: 3.7
        });
        water.rotation.x = -Math.PI / 2;
        water.position.y = 0.5;
        scene.add(water);
    }

    function createRealisticIsland() {
        const geo = new THREE.PlaneGeometry(300, 300, 200, 200);
        const pos = geo.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            let x = pos.getX(i), y = pos.getY(i);
            let d = Math.sqrt(x*x + y*y);
            
            // Процедурная генерация ландшафта (как настоящий остров)
            let height = -5;
            if (d < 110) {
                // Основная форма + холмистость
                height = Math.pow(Math.cos(d/75), 2) * 20;
                height += Math.sin(x/4) * Math.cos(y/4) * 2; // Мелкие камни
            }
            pos.setZ(i, height);
        }
        geo.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: 0xc2b280, roughness: 1, flatShading: false });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2;
        scene.add(mesh);

        // Храм
        createTemple(0, 20.5, 0);

        // Растительность (Пальмы)
        for(let i = 0; i < 50; i++) {
            let a = Math.random() * Math.PI * 2;
            let r = 25 + Math.random() * 80;
            spawnPalm(Math.cos(a)*r, Math.sin(a)*r);
        }
    }

    function createTemple(x, y, z) {
        const temple = new THREE.Group();
        for(let i = 0; i < 22; i++) {
            const stripe = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.4, 12),
                new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? 0xffffff : 0x0033cc })
            );
            stripe.position.y = i * 0.4;
            temple.add(stripe);
        }
        const dome = new THREE.Mesh(new THREE.SphereGeometry(4.5, 32, 16, 0, 6.3, 0, 1.6), new THREE.MeshStandardMaterial({color: 0xffcc00, metalness: 1, roughness: 0}));
        dome.position.y = 8.8;
        temple.add(dome);
        temple.position.set(x, y, z);
        scene.add(temple);
        colliders.push({ x: x, z: z, r: 8 });
    }

    function spawnPalm(x, z) {
        const h = 7 + Math.random() * 4;
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, h), new THREE.MeshStandardMaterial({color: 0x4b3621}));
        trunk.position.set(x, h/2 + 2, z);
        scene.add(trunk);
        colliders.push({ x: x, z: z, r: 1 });
    }

    function setupInput() {
        const onKeyDown = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
            }
        };
        const onKeyUp = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        };
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();

        if (controls.isLocked) {
            velocity.x -= velocity.x * 10.0 * dt;
            velocity.z -= velocity.z * 10.0 * dt;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 200.0 * dt;
            if (moveLeft || moveRight) velocity.x -= direction.x * 200.0 * dt;

            // Коллизия
            const nextX = camera.position.x - velocity.x * dt;
            const nextZ = camera.position.z - velocity.z * dt;
            
            let collision = false;
            colliders.forEach(c => {
                if (Math.sqrt((nextX - c.x)**2 + (nextZ - c.z)**2) < c.r) collision = true;
            });

            if (!collision) {
                controls.moveRight(-velocity.x * dt);
                controls.moveForward(-velocity.z * dt);
            }
        }

        // Плавная высота под ландшафт
        let d = Math.sqrt(camera.position.x**2 + camera.position.z**2);
        let targetH = (d < 110 ? Math.pow(Math.cos(d/75), 2) * 20 : 0) + 1.8;
        camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetH, 0.1);

        water.material.uniforms['time'].value += dt;
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
