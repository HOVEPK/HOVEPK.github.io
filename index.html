<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Private Island: Exact Replica</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; }
        #sound-panel {
            position: absolute; top: 15px; right: 15px; z-index: 1000;
            background: rgba(0,0,0,0.8); padding: 5px; border-radius: 10px; border: 1px solid #444;
        }
        #temple-player { display: none; }
        #joy-base {
            position: absolute; width: 100px; height: 100px;
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%; display: none; pointer-events: none; z-index: 100;
        }
        #joy-stick {
            position: absolute; width: 40px; height: 40px;
            background: #fff; border-radius: 50%; top: 30px; left: 30px;
        }
    </style>
</head>
<body>

    <div id="sound-panel">
        <div id="world-player"><iframe width="100" height="60" src="https://www.myinstants.com/instant/jeffrey-epstein-edit-98984/embed/" frameborder="0" scrolling="no"></iframe></div>
        <div id="temple-player"><iframe width="100" height="60" src="https://www.myinstants.com/instant/lock-in-epstein-edition-slowed-64683/embed/" frameborder="0" scrolling="no"></iframe></div>
    </div>

    <div id="joy-base"><div id="joy-stick"></div></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { Water } from 'three/addons/objects/Water.js';

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x88aabb, 0.0007);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(200, 45, 200);
        camera.rotation.order = 'YXZ';

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sunLight = new THREE.DirectionalLight(0xfff4d6, 2.5);
        sunLight.position.set(100, 300, 100);
        scene.add(sunLight);

        // --- SKY & WATER ---
        const sun = new THREE.Vector3();
        const sky = new Sky(); sky.scale.setScalar(10000); scene.add(sky);
        sun.setFromSphericalCoords(1, THREE.MathUtils.degToRad(84), THREE.MathUtils.degToRad(170));
        sky.material.uniforms['sunPosition'].value.copy(sun);

        const water = new Water(new THREE.PlaneGeometry(10000, 10000), {
            textureWidth: 512, textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', t => t.wrapS = t.wrapT = THREE.RepeatWrapping),
            sunDirection: sun, sunColor: 0xffffff, waterColor: 0x003b44, distortionScale: 3.5
        });
        water.rotation.x = -Math.PI / 2; water.position.y = -2; scene.add(water);

        // --- LANDSCAPE WITH ROCKS ---
        const islandRadius = 400;
        const terrainGeo = new THREE.CylinderGeometry(islandRadius, islandRadius + 40, 30, 96, 20);
        const terrainMat = new THREE.MeshStandardMaterial({ color: 0xdfc48c });
        const terrain = new THREE.Mesh(terrainGeo, terrainMat);
        terrain.position.y = -15;

        const pos = terrain.geometry.attributes.position;
        for(let i=0; i<pos.count; i++) {
            let x = pos.getX(i), z = pos.getZ(i);
            if(pos.getY(i) > 0) {
                let d = Math.sqrt(x*x + z*z);
                let h = Math.sin(x*0.02)*Math.cos(z*0.02)*12;
                if (d < 120) h = 15; // Рівна площадка для храму
                pos.setY(i, 15 + h);
            }
        }
        terrain.geometry.computeVertexNormals();
        scene.add(terrain);

        // --- TEMPLE REPLICA ---
        const temple = new THREE.Group();
        const tS = 85; 

        // Maze Floor (Червоний лабіринт як на фото)
        const floorGeo = new THREE.PlaneGeometry(160, 160);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 15.1;
        floor.position.z = 80;
        temple.add(floor);

        // Червоні смуги лабіринту (спрощено)
        for(let i=0; i<10; i++) {
            const line = new THREE.Mesh(new THREE.BoxGeometry(140 - i*15, 0.1, 2), new THREE.MeshStandardMaterial({color: 0xaa0000}));
            line.position.set(0, 15.2, 80 + (i-5)*12);
            temple.add(line);
        }

        // Walls with Blue Stripes
        for(let i=0; i<45; i++) {
            const h = 1.2, y = 15 + i*h, isBlue = i % 4 === 0;
            const mat = new THREE.MeshStandardMaterial({ color: isBlue ? 0x0033aa : 0xffffff });
            const wall = (w,d,px,pz) => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                m.position.set(px, y, pz); temple.add(m);
            };
            wall(tS, 5, 0, -tS/2); wall(5, tS, -tS/2, 0); wall(5, tS, tS/2, 0);
            if (i < 20) { wall(25, 5, -30, tS/2); wall(25, 5, 30, tS/2); } // Вхід
            else wall(tS, 5, 0, tS/2);
        }

        // Golden Dome
        const dome = new THREE.Mesh(new THREE.SphereGeometry(tS/2, 48, 24, 0, Math.PI*2, 0, Math.PI/2),
            new THREE.MeshStandardMaterial({color: 0xffcc00, metalness: 0.9, roughness: 0.1}));
        dome.position.y = 15 + 45*1.2;
        temple.add(dome);
        scene.add(temple);

        // --- REAL PALMS (BENT TRUNKS) ---
        const palmMat = new THREE.MeshStandardMaterial({ color: 0x114411, side: THREE.DoubleSide });
        function createPalm(x, z) {
            const group = new THREE.Group();
            // Curved trunk
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(Math.random()*5, 15, Math.random()*5),
                new THREE.Vector3(Math.random()*10, 35, Math.random()*10)
            ]);
            const trunkGeo = new THREE.TubeGeometry(curve, 10, 0.8, 8, false);
            const trunk = new THREE.Mesh(trunkGeo, new THREE.MeshStandardMaterial({color: 0x443322}));
            group.add(trunk);
            
            // Leaves with wind
            for(let i=0; i<12; i++) {
                const leaf = new THREE.Mesh(new THREE.BoxGeometry(18, 0.2, 3), palmMat);
                leaf.position.set(curve.getPoint(1).x, 35, curve.getPoint(1).z);
                leaf.rotation.y = i * Math.PI/6;
                leaf.rotation.z = 0.6;
                group.add(leaf);
            }
            group.position.set(x, 15, z);
            scene.add(group);
        }
        for(let i=0; i<30; i++) {
            let a = Math.random()*Math.PI*2, r = 130 + Math.random()*200;
            createPalm(Math.cos(a)*r, Math.sin(a)*r);
        }

        // --- CONTROLS ---
        let joyId = null, lookId = null, move = { x: 0, y: 0, startX: 0, startY: 0 }, rot = { yaw: 0, pitch: 0 }, lastLook = { x: 0, y: 0 };
        const joyB = document.getElementById('joy-base'), joyS = document.getElementById('joy-stick');

        window.addEventListener('pointerdown', e => {
            if (e.clientX < window.innerWidth/2) { joyId = e.pointerId; move.startX = e.clientX; move.startY = e.clientY; joyB.style.display = 'block'; joyB.style.left = (e.clientX-50)+'px'; joyB.style.top = (e.clientY-50)+'px'; }
            else { lookId = e.pointerId; lastLook.x = e.clientX; lastLook.y = e.clientY; }
        });
        window.addEventListener('pointermove', e => {
            if (e.pointerId === joyId) {
                let dx = e.clientX - move.startX, dy = e.clientY - move.startY;
                let d = Math.min(Math.sqrt(dx*dx+dy*dy), 40), a = Math.atan2(dy, dx);
                move.x = Math.cos(a)*(d/40); move.y = Math.sin(a)*(d/40);
                joyS.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
            } else if (e.pointerId === lookId) {
                rot.yaw -= (e.clientX - lastLook.x) * 0.006; rot.pitch -= (e.clientY - lastLook.y) * 0.006;
                rot.pitch = Math.max(-1.4, Math.min(1.4, rot.pitch)); lastLook.x = e.clientX; lastLook.y = e.clientY;
            }
        });
        window.addEventListener('pointerup', () => { joyId = null; move.x = 0; move.y = 0; joyB.style.display = 'none'; lookId = null; });

        // --- ANIMATION ---
        const worldUI = document.getElementById('world-player'), templeUI = document.getElementById('temple-player');
        let isInside = false;
        function animate() {
            requestAnimationFrame(animate);
            if (joyId !== null) {
                const f = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); f.y = 0; f.normalize();
                const r = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); r.y = 0; r.normalize();
                camera.position.addScaledVector(f, -move.y * 1.8); camera.position.addScaledVector(r, move.x * 1.8);
                const d = camera.position.length();
                if (d < 35 && !isInside) { camera.position.set(0, 25, 0); isInside = true; worldUI.style.display = 'none'; templeUI.style.display = 'block'; }
                else if (d > 70 && isInside) { isInside = false; worldUI.style.display = 'block'; templeUI.style.display = 'none'; }
            }
            camera.rotation.y = rot.yaw; camera.rotation.x = rot.pitch;
            water.material.uniforms['time'].value += 0.01;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
