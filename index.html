<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Private Island — Мобільна версія</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; font-family:Arial; color:#fff; }
    canvas { display:block; }
    #ui {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }
    #joystick {
      position: absolute;
      bottom: 30px;
      left: 30px;
      width: 140px;
      height: 140px;
      background: rgba(200,200,255,0.15);
      border: 2px solid rgba(200,200,255,0.4);
      border-radius: 50%;
      pointer-events: auto;
      touch-action: none;
      user-select: none;
    }
    #knob {
      position: absolute;
      width: 70px;
      height: 70px;
      background: rgba(220,220,255,0.5);
      border-radius: 50%;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    #touch-area {
      position: absolute;
      top: 0; right: 0; bottom: 0; left: 40%;
      pointer-events: auto;
      touch-action: none;
    }
    #error {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      padding: 20px 40px;
      border-radius: 12px;
      text-align: center;
      max-width: 90%;
      display: none;
    }
  </style>
</head>
<body>

  <div id="ui">
    <div id="joystick"><div id="knob"></div></div>
    <div id="touch-area"></div>
    <div id="error">Не вдалося запустити 3D<br>Спробуй Chrome / онови сторінку<br>або відкрий на комп'ютері</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>

  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0.55, 0.78, 1.0);
    scene.fog = new THREE.FogExp2(0x88aaff, 0.0008);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1200);
    camera.position.set(25, 6, 45);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);

    // Світло
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const sun = new THREE.DirectionalLight(0xfff8e8, 1.1);
    sun.position.set(60, 100, 50);
    scene.add(sun);

    // Вода
    const water = new THREE.Mesh(
      new THREE.PlaneGeometry(1200, 1200),
      new THREE.MeshStandardMaterial({
        color: 0x1e70a0,
        roughness: 0.2,
        metalness: 0.35,
        transparent: true,
        opacity: 0.92
      })
    );
    water.rotation.x = -Math.PI/2;
    water.position.y = -0.4;
    scene.add(water);

    // Острів
    const island = new THREE.Mesh(
      new THREE.CylinderGeometry(90, 70, 15, 24, 1),
      new THREE.MeshStandardMaterial({color: 0xe0c8a0, roughness: 0.95})
    );
    island.position.y = -7.5;
    scene.add(island);

    // Храм
    const temple = new THREE.Group();

    // Основа
    const base = new THREE.Mesh(
      new THREE.BoxGeometry(26, 20, 26),
      new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.8})
    );
    base.position.y = 10;
    temple.add(base);

    // Сині смуги (спрощено)
    const stripeMat = new THREE.MeshStandardMaterial({color: 0x0040aa});
    for (let i = 0; i < 6; i++) {
      const stripe = new THREE.Mesh(
        new THREE.BoxGeometry(26.2, 2.8, 26.2),
        stripeMat
      );
      stripe.position.y = 2 + i * 3.4;
      temple.add(stripe);
    }

    // Купол
    const dome = new THREE.Mesh(
      new THREE.SphereGeometry(14, 28, 12, 0, Math.PI*2, 0, Math.PI/2),
      new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 0.9, roughness: 0.1})
    );
    dome.position.y = 20 + 10;
    temple.add(dome);

    temple.position.set(0, 0, -15);
    scene.add(temple);

    // Пальми (2-3 шт)
    function addPalm(x, z) {
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.9, 1.4, 16, 8),
        new THREE.MeshStandardMaterial({color: 0x7a4a2a})
      );
      trunk.position.set(x, 8, z);
      scene.add(trunk);

      const leaves = new THREE.Group();
      for (let a = 0; a < 7; a++) {
        const leaf = new THREE.Mesh(
          new THREE.PlaneGeometry(10, 4),
          new THREE.MeshStandardMaterial({color: 0x1a8c1a, side: THREE.DoubleSide})
        );
        leaf.position.y = 16;
        leaf.rotation.y = a * 0.9 + Math.random()*0.4;
        leaf.rotation.x = -0.5;
        leaves.add(leaf);
      }
      leaves.position.set(x, 0, z);
      scene.add(leaves);
    }
    addPalm(35, -5); addPalm(-40, 10); addPalm(15, 35);

    // ==================== КЕРУВАННЯ ====================
    const move = { x: 0, z: 0 };
    const look = { x: 0, y: 0 };

    // Джойстик
    const joy = document.getElementById('joystick');
    const knob = document.getElementById('knob');
    let touchId = null;
    let joyCenterX, joyCenterY;

    joy.addEventListener('touchstart', e => {
      e.preventDefault();
      if (touchId === null) {
        const t = e.touches[0];
        touchId = t.identifier;
        joyCenterX = t.clientX;
        joyCenterY = t.clientY;
        knob.style.left = '50%';
        knob.style.top = '50%';
      }
    });

    joy.addEventListener('touchmove', e => {
      e.preventDefault();
      for (const t of e.touches) {
        if (t.identifier === touchId) {
          let dx = t.clientX - joyCenterX;
          let dy = t.clientY - joyCenterY;
          const dist = Math.hypot(dx, dy);
          const maxDist = 60;
          if (dist > maxDist) {
            dx *= maxDist / dist;
            dy *= maxDist / dist;
          }
          knob.style.left = `calc(50% + ${dx}px)`;
          knob.style.top  = `calc(50% + ${dy}px)`;

          move.x = dx / maxDist;
          move.z = dy / maxDist;
          break;
        }
      }
    });

    joy.addEventListener('touchend', e => {
      for (const t of e.changedTouches) {
        if (t.identifier === touchId) {
          touchId = null;
          move.x = move.z = 0;
          knob.style.left = '50%';
          knob.style.top = '50%';
        }
      }
    });

    // Огляд камерою (права частина екрану)
    const touchArea = document.getElementById('touch-area');
    let lookTouchId = null;
    let prevX = 0, prevY = 0;

    touchArea.addEventListener('touchstart', e => {
      if (lookTouchId === null && e.touches.length) {
        const t = e.touches[0];
        if (t.clientX > innerWidth * 0.4) {
          lookTouchId = t.identifier;
          prevX = t.clientX;
          prevY = t.clientY;
        }
      }
    }, {passive: false});

    touchArea.addEventListener('touchmove', e => {
      e.preventDefault();
      for (const t of e.touches) {
        if (t.identifier === lookTouchId) {
          const dx = t.clientX - prevX;
          const dy = t.clientY - prevY;
          look.y -= dx * 0.0035;
          look.x -= dy * 0.0035;
          look.x = Math.max(-1.4, Math.min(1.4, look.x));
          prevX = t.clientX;
          prevY = t.clientY;
          break;
        }
      }
    }, {passive: false});

    touchArea.addEventListener('touchend', e => {
      for (const t of e.changedTouches) {
        if (t.identifier === lookTouchId) lookTouchId = null;
      }
    });

    // Анімація
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Рух
      const speed = 0.25;
      const dir = new THREE.Vector3(move.x, 0, move.z).normalize();
      const right = new THREE.Vector3(Math.sin(look.y), 0, Math.cos(look.y));
      const forward = new THREE.Vector3(
        Math.sin(look.y + Math.PI/2),
        0,
        Math.cos(look.y + Math.PI/2)
      );

      camera.position.add(right.multiplyScalar(dir.x * speed));
      camera.position.add(forward.multiplyScalar(-dir.z * speed)); // -z бо вперед негативний

      // Обертання камери
      camera.rotation.set(look.x, look.y, 0, 'YXZ');

      // Хвилі води
      water.material.color.setHSL(0.58 + Math.sin(time*1.2)*0.015, 0.65, 0.48 + Math.sin(time*0.8)*0.03);

      renderer.render(scene, camera);
    }

    // Запуск + помилка якщо не працює
    try {
      animate();
    } catch(e) {
      console.error(e);
      document.getElementById('error').style.display = 'block';
    }

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
