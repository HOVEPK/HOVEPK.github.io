<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Private Island — Храм на острові</title>
  <style>
    body { margin:0; overflow:hidden; font-family:Arial, sans-serif; background:#000; }
    canvas { display:block; }
    #ui {
      position: absolute;
      inset: 0;
      pointer-events: none;
      color: white;
      user-select: none;
    }
    #joystick {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 120px;
      height: 120px;
      background: rgba(255,255,255,0.12);
      border-radius: 50%;
      pointer-events: auto;
      touch-action: none;
    }
    #joystick-knob {
      position: absolute;
      width: 60px;
      height: 60px;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    #touch-cam {
      position: absolute;
      top: 0; right: 0; bottom: 0; left: 50%;
      pointer-events: auto;
      touch-action: none;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="info">WASD / стік — рух<br>Миша / права половина екрану — огляд</div>
    <div id="joystick"><div id="joystick-knob"></div></div>
    <div id="touch-cam"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/PointerLockControls.min.js"></script>

  <script>
    // ==================== НАЛАШТУВАННЯ ====================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0.6, 0.8, 1.0);
    scene.fog = new THREE.FogExp2(0x88aaff, 0.0006);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 2000);
    camera.position.set(40, 8, 60);

    const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:"high-performance"});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Освітлення
    const sun = new THREE.DirectionalLight(0xfffcee, 1.4);
    sun.position.set(50, 120, 80);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 500;
    scene.add(sun);

    scene.add(new THREE.AmbientLight(0x88ccff, 0.5));

    // Вода
    const waterGeo = new THREE.PlaneGeometry(1000, 1000);
    const waterMat = new THREE.MeshStandardMaterial({
      color: 0x2080c0,
      roughness: 0.1,
      metalness: 0.3,
      transparent: true,
      opacity: 0.88,
      side: THREE.DoubleSide
    });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.rotation.x = -Math.PI/2;
    water.position.y = -0.5;
    water.receiveShadow = true;
    scene.add(water);

    // Земля / острів
    const islandGeo = new THREE.CylinderGeometry(80, 60, 12, 32, 1, true);
    const islandMat = new THREE.MeshStandardMaterial({color: 0xe0d0b0, roughness: 0.9});
    const island = new THREE.Mesh(islandGeo, islandMat);
    island.position.y = -6;
    island.receiveShadow = true;
    scene.add(island);

    // Храм
    const templeGroup = new THREE.Group();

    // Основа храму (куб з смугами)
    const baseGeo = new THREE.BoxGeometry(24, 18, 24);
    const baseCanvas = document.createElement("canvas");
    baseCanvas.width = 512; baseCanvas.height = 512;
    const ctx = baseCanvas.getContext("2d");
    ctx.fillStyle = "#ffffff"; ctx.fillRect(0,0,512,512);
    for(let i=0; i<8; i++){
      ctx.fillStyle = "#0044aa";
      ctx.fillRect(0, i*64, 512, 32);
    }
    const baseTex = new THREE.CanvasTexture(baseCanvas);
    baseTex.repeat.set(3,1.5);
    baseTex.wrapS = baseTex.wrapT = THREE.RepeatWrapping;
    const baseMat = new THREE.MeshStandardMaterial({map:baseTex, roughness:0.7, metalness:0.1});
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.y = 9;
    base.castShadow = base.receiveShadow = true;
    templeGroup.add(base);

    // Купол
    const domeGeo = new THREE.SphereGeometry(13, 32, 16, 0, Math.PI*2, 0, Math.PI/2);
    const domeMat = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      metalness: 0.95,
      roughness: 0.05,
      envMapIntensity: 1.2
    });
    const dome = new THREE.Mesh(domeGeo, domeMat);
    dome.position.y = 18 + 9;
    dome.castShadow = true;
    templeGroup.add(dome);

    // Арка / двері (спрощено)
    const doorGeo = new THREE.BoxGeometry(10, 14, 1);
    const doorMat = new THREE.MeshStandardMaterial({color:0x8b5a2b, roughness:0.8});
    const door = new THREE.Mesh(doorGeo, doorMat);
    door.position.set(0, 7, 12.1);
    templeGroup.add(door);

    templeGroup.position.set(0, 0, -20);
    scene.add(templeGroup);

    // Пальми (дуже спрощені)
    function createPalm(x, z) {
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.8, 1.2, 14, 8),
        new THREE.MeshStandardMaterial({color:0x8b4513, roughness:0.9})
      );
      trunk.position.set(x, 7, z);
      trunk.castShadow = true;
      scene.add(trunk);

      const leavesGroup = new THREE.Group();
      for(let i=0; i<6; i++){
        const leaf = new THREE.Mesh(
          new THREE.PlaneGeometry(8, 3),
          new THREE.MeshStandardMaterial({color:0x228b22, side:THREE.DoubleSide, transparent:true, opacity:0.9})
        );
        leaf.position.y = 14;
        leaf.rotation.y = i * Math.PI/3 + Math.random()*0.5;
        leaf.rotation.x = -0.4 + Math.random()*0.3;
        leavesGroup.add(leaf);
      }
      leavesGroup.position.set(x, 0, z);
      scene.add(leavesGroup);
    }
    createPalm(30, -10); createPalm(-35, -15); createPalm(20, 30); createPalm(-25, 25);

    // Небо покращене градієнтом
    scene.background = new THREE.Color(0.5, 0.75, 1);
    const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
    const skyMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.BackSide,
      vertexColors: true
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    const skyPos = sky.geometry.attributes.position;
    for(let i=0; i<skyPos.count; i++){
      const y = skyPos.getY(i);
      const t = (y + 1000)/2000;
      const col = new THREE.Color().lerpColors(
        new THREE.Color(0x88aaff),
        new THREE.Color(0xffeecc),
        t*t
      );
      sky.geometry.attributes.color.setXYZ(i, col.r, col.g, col.b);
    }
    sky.geometry.attributes.color.needsUpdate = true;
    scene.add(sky);

    // ==================== КЕРУВАННЯ ====================
    const controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    document.addEventListener('click', () => {
      if (!controls.isLocked) controls.lock();
    });

    // Фізичні параметри
    const player = {
      height: 5.5,
      speed: 0.18,
      velocity: new THREE.Vector3(),
      direction: new THREE.Vector3()
    };

    const keys = {};
    window.addEventListener('keydown', e=>keys[e.code]=true);
    window.addEventListener('keyup',   e=>keys[e.code]=false);

    // Джойстик для телефону
    const joy = document.getElementById('joystick');
    const knob = document.getElementById('joystick-knob');
    let joyActive = false, joyStart = {x:0,y:0}, joyDelta = {x:0,y:0};

    joy.addEventListener('touchstart', e=>{
      e.preventDefault();
      joyActive = true;
      const t = e.touches[0];
      joyStart.x = t.clientX; joyStart.y = t.clientY;
      knob.style.left = '50%'; knob.style.top = '50%';
    });
    joy.addEventListener('touchmove', e=>{
      e.preventDefault();
      if(!joyActive) return;
      const t = e.touches[0];
      joyDelta.x = (t.clientX - joyStart.x) * 1.5;
      joyDelta.y = (t.clientY - joyStart.y) * 1.5;
      const len = Math.min(60, Math.hypot(joyDelta.x, joyDelta.y));
      const ang = Math.atan2(joyDelta.y, joyDelta.x);
      knob.style.left = `calc(50% + ${Math.cos(ang)*len}px)`;
      knob.style.top  = `calc(50% + ${Math.sin(ang)*len}px)`;
    });
    joy.addEventListener('touchend', ()=>{
      joyActive = false;
      joyDelta = {x:0,y:0};
      knob.style.left = '50%'; knob.style.top = '50%';
    });

    // Сенсорне керування камерою (права половина)
    const touchCam = document.getElementById('touch-cam');
    let camTouchId = null, prevCamX = 0, prevCamY = 0;

    touchCam.addEventListener('touchstart', e=>{
      if (camTouchId === null && e.touches.length > 0) {
        const t = e.touches[0];
        if (t.clientX > innerWidth/2) {
          camTouchId = t.identifier;
          prevCamX = t.clientX;
          prevCamY = t.clientY;
        }
      }
    }, {passive:false});

    touchCam.addEventListener('touchmove', e=>{
      e.preventDefault();
      for (const t of e.touches) {
        if (t.identifier === camTouchId) {
          const dx = (t.clientX - prevCamX) * 0.15;
          const dy = (t.clientY - prevCamY) * 0.15;
          controls.moveRight(-dx);
          controls.getObject().rotation.y -= dx * 0.017; // ≈ π/180
          controls.getObject().rotation.x -= dy * 0.017;
          controls.getObject().rotation.x = Math.max(-1.5, Math.min(1.5, controls.getObject().rotation.x));
          prevCamX = t.clientX;
          prevCamY = t.clientY;
          break;
        }
      }
    }, {passive:false});

    touchCam.addEventListener('touchend', e=>{
      for (const t of e.changedTouches) {
        if (t.identifier === camTouchId) camTouchId = null;
      }
    });

    // Колізія (дуже проста — коробка храму + земля)
    function checkCollision(newPos) {
      const templeBox = new THREE.Box3().setFromObject(templeGroup);
      const playerBox = new THREE.Sphere(newPos, 2);
      if (playerBox.intersectsBox(templeBox)) return true;
      if (newPos.y < 1.5) return true; // земля
      return false;
    }

    // Анімація хвиль води
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Хвилі
      water.material.normalScale.set(0.8 + Math.sin(time*2)*0.2, 0.8 + Math.cos(time*1.7)*0.2);

      // Рух гравця
      player.direction.set(0,0,0);

      if (keys['KeyW'] || keys['ArrowUp']) player.direction.z = -1;
      if (keys['KeyS'] || keys['ArrowDown']) player.direction.z =  1;
      if (keys['KeyA'] || keys['ArrowLeft']) player.direction.x = -1;
      if (keys['KeyD'] || keys['ArrowRight']) player.direction.x =  1;

      // Джойстик
      if (joyActive) {
        player.direction.x += joyDelta.x * 0.008;
        player.direction.z += joyDelta.y * 0.008;
      }

      player.direction.normalize();

      controls.moveRight(player.direction.x * player.speed * 60);
      controls.moveForward(player.direction.z * player.speed * 60);

      // Колізія
      const newPos = controls.getObject().position.clone();
      if (checkCollision(newPos)) {
        controls.moveRight(-player.direction.x * player.speed * 60);
        controls.moveForward(-player.direction.z * player.speed * 60);
      }

      renderer.render(scene, camera);
    }
    animate();

    // Ресайз
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
