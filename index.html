<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Temple: Wind & Grass Lush</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        canvas { display: block; }
        #joy-base {
            position: absolute; width: 100px; height: 100px;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; display: none; pointer-events: none; z-index: 100;
        }
        #joy-stick {
            position: absolute; width: 40px; height: 40px;
            background: #fff; border-radius: 50%; top: 30px; left: 30px;
        }
    </style>
</head>
<body>
    <div id="joy-base"><div id="joy-stick"></div></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { Water } from 'three/addons/objects/Water.js';

        // --- SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(40, 2.5, 40);
        camera.rotation.order = 'YXZ';

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        scene.add(new THREE.HemisphereLight(0x87CEEB, 0x3d2b1f, 1.2));
        const sun = new THREE.Vector3();
        const sky = new Sky(); sky.scale.setScalar(10000); scene.add(sky);
        sun.setFromSphericalCoords(1, THREE.MathUtils.degToRad(85), THREE.MathUtils.degToRad(180));
        sky.material.uniforms['sunPosition'].value.copy(sun);

        // --- WATER & ISLAND ---
        const water = new Water(new THREE.PlaneGeometry(5000, 5000), {
            textureWidth: 512, textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', t => t.wrapS = t.wrapT = THREE.RepeatWrapping),
            sunDirection: sun, sunColor: 0xffffff, waterColor: 0x001e0f, distortionScale: 3.0
        });
        water.rotation.x = -Math.PI / 2; water.position.y = -1; scene.add(water);

        const island = new THREE.Mesh(new THREE.CylinderGeometry(80, 85, 10, 64), new THREE.MeshStandardMaterial({ color: 0xeed2af }));
        island.position.y = -5.5; island.receiveShadow = true; scene.add(island);

        // --- LUSH GRASS WITH WIND ---
        const grassItems = [];
        function addLushGrass() {
            const shape = new THREE.BufferGeometry();
            const vertices = new Float32Array([-0.15, 0, 0, 0.15, 0, 0, 0, 0.45, 0]); // Менші трикутники
            shape.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            for(let i = 0; i < 2500; i++) {
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(0.3, 0.8, 0.4 + Math.random() * 0.2), 
                    side: THREE.DoubleSide 
                });
                const group = new THREE.Group();
                const a = Math.random() * Math.PI * 2, r = 10 + Math.random() * 65;
                const x = Math.cos(a) * r, z = Math.sin(a) * r;

                // Скидаємо траву, якщо вона всередині храму
                if (Math.abs(x) < 9 && Math.abs(z) < 9) continue;

                for(let j = 0; j < 2; j++) {
                    const blade = new THREE.Mesh(shape, mat);
                    blade.rotation.y = (Math.PI / 2) * j;
                    group.add(blade);
                }
                group.position.set(x, -0.5, z);
                group.rotation.y = Math.random() * Math.PI;
                scene.add(group);
                grassItems.push(group);
            }
        }
        addLushGrass();

        // --- PALMS WITH WIND ---
        const palmLeaves = [];
        function addPalms() {
            [[30,30], [-30,25], [25,-35], [-35,-20], [50, 0], [-50, -50]].forEach(pos => {
                const p = new THREE.Group();
                const t = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 12), new THREE.MeshStandardMaterial({color: 0x3d2b1f}));
                t.position.y = 6; p.add(t);
                for(let j=0; j<8; j++){
                    const l = new THREE.Mesh(new THREE.SphereGeometry(6, 8, 2), new THREE.MeshStandardMaterial({color: 0x228B22}));
                    l.scale.set(1, 0.04, 0.3); l.position.y = 12; l.rotation.y = j; l.rotation.z = 0.7;
                    p.add(l);
                    palmLeaves.push(l);
                }
                p.position.set(pos[0], -0.5, pos[1]); scene.add(p);
            });
        }
        addPalms();

        // --- TEMPLE ---
        const temple = new THREE.Group();
        const wallH = 12, wallW = 16;
        for(let i=0; i<15; i++) {
            const h = wallH/15, y = i*h + h/2, blue = i%2===0;
            const mat = new THREE.MeshStandardMaterial({ color: blue ? 0x0044ff : 0xffffff });
            const b = new THREE.Mesh(new THREE.BoxGeometry(wallW, h, 0.8), mat); b.position.set(0, y, -wallW/2); temple.add(b);
            const l = new THREE.Mesh(new THREE.BoxGeometry(0.8, h, wallW), mat); l.position.set(-wallW/2, y, 0); temple.add(l);
            const r = new THREE.Mesh(new THREE.BoxGeometry(0.8, h, wallW), mat); r.position.set(wallW/2, y, 0); temple.add(r);
            if(i > 8) {
                const f = new THREE.Mesh(new THREE.BoxGeometry(wallW, h, 0.8), mat); f.position.set(0, y, wallW/2); temple.add(f);
            } else {
                const fL = new THREE.Mesh(new THREE.BoxGeometry(6, h, 0.8), mat); fL.position.set(-5, y, wallW/2); temple.add(fL);
                const fR = new THREE.Mesh(new THREE.BoxGeometry(6, h, 0.8), mat); fR.position.set(5, y, wallW/2); temple.add(fR);
            }
        }
        const dome = new THREE.Mesh(new THREE.SphereGeometry(8, 32, 16, 0, Math.PI*2, 0, Math.PI/2), new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 0.8, roughness: 0.2}));
        dome.position.y = wallH; temple.add(dome);
        scene.add(temple);

        const door = new THREE.Mesh(new THREE.BoxGeometry(4, 7, 0.3), new THREE.MeshStandardMaterial({color: 0x553311}));
        door.position.set(0, 3.5, 8.1); scene.add(door);

        // --- CONTROLS ---
        let joyId = null, lookId = null;
        let move = { x: 0, y: 0, startX: 0, startY: 0 };
        let rot = { yaw: 0, pitch: 0 };
        let lastLook = { x: 0, y: 0 };
        const joyB = document.getElementById('joy-base'), joyS = document.getElementById('joy-stick');

        window.addEventListener('pointerdown', e => {
            if (e.clientX < window.innerWidth / 2 && joyId === null) {
                joyId = e.pointerId; move.startX = e.clientX; move.startY = e.clientY;
                joyB.style.display = 'block'; joyB.style.left = (e.clientX - 50) + 'px'; joyB.style.top = (e.clientY - 50) + 'px';
            } else if (lookId === null) {
                lookId = e.pointerId; lastLook.x = e.clientX; lastLook.y = e.clientY;
            }
        });

        window.addEventListener('pointermove', e => {
            if (e.pointerId === joyId) {
                let dx = e.clientX - move.startX, dy = e.clientY - move.startY;
                let d = Math.min(Math.sqrt(dx*dx+dy*dy), 40), a = Math.atan2(dy, dx);
                move.x = Math.cos(a)*(d/40); move.y = Math.sin(a)*(d/40);
                joyS.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
            } else if (e.pointerId === lookId) {
                rot.yaw -= (e.clientX - lastLook.x) * 0.007;
                rot.pitch -= (e.clientY - lastLook.y) * 0.007;
                rot.pitch = Math.max(-1.4, Math.min(1.4, rot.pitch));
                lastLook.x = e.clientX; lastLook.y = e.clientY;
            }
        });

        window.addEventListener('pointerup', e => {
            if (e.pointerId === joyId) { joyId = null; move.x = 0; move.y = 0; joyB.style.display = 'none'; }
            else if (e.pointerId === lookId) lookId = null;
        });

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.002;

            // Ефект вітру
            grassItems.forEach((g, i) => {
                g.rotation.z = Math.sin(time + i) * 0.1;
                g.rotation.x = Math.cos(time * 0.5 + i) * 0.05;
            });
            palmLeaves.forEach((l, i) => {
                l.rotation.z = 0.7 + Math.sin(time + i) * 0.05;
            });

            if (joyId !== null) {
                const f = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); f.y = 0; f.normalize();
                const r = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); r.y = 0; r.normalize();
                const old = camera.position.clone();
                camera.position.addScaledVector(f, -move.y * 0.3);
                camera.position.addScaledVector(r, move.x * 0.3);

                // TELEPORT
                if (Math.abs(camera.position.x) < 2.2 && Math.abs(camera.position.z - 8.2) < 0.8) {
                    camera.position.set(0, 2, 0);
                }

                // COLLISION
                const inX = Math.abs(camera.position.x), inZ = Math.abs(camera.position.z);
                // Зовнішні стіни храму
                if (inX < 8.5 && inZ < 8.5 && camera.position.length() > 5) {
                    if (camera.position.z < 7.5) camera.position.copy(old); // Тверді стіни скрізь, крім входу
                }
                // Внутрішні стіни
                if (camera.position.length() < 5) {
                     if (inX > 7.1 || inZ > 7.1) camera.position.copy(old);
                }
                // Острів
                if (camera.position.length() > 78) camera.position.copy(old);
            }

            camera.rotation.y = rot.yaw; camera.rotation.x = rot.pitch;
            water.material.uniforms['time'].value += 1.0 / 60.0;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
