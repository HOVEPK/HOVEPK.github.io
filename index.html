<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Little St. James: Definitive Edition</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
        #joystick-wrapper {
            position: absolute; bottom: 40px; left: 40px;
            width: 120px; height: 120px; background: rgba(255,255,255,0.1);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.2); touch-action: none;
        }
        #joystick-stick {
            position: absolute; top: 35px; left: 35px;
            width: 50px; height: 50px; background: #fff; border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; opacity: 0.5;
        }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="joystick-wrapper"><div id="joystick-stick"></div></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';

    let scene, camera, renderer, water, clock, sun;
    let moveDir = { x: 0, y: 0 };
    let lookYaw = 0, lookPitch = 0;
    const colliders = []; // Массив объектов для коллизии

    init();

    function init() {
        scene = new THREE.Scene();
        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2500);
        camera.rotation.order = 'YXZ';
        camera.position.set(45, 2, 45);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        setupSkyAndWater();
        createRealisticIsland();
        setupControls();

        window.addEventListener('resize', onWindowResize);
        animate();
    }

    function setupSkyAndWater() {
        const sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);
        sun = new THREE.Vector3();
        const phi = THREE.MathUtils.degToRad(86); 
        sun.setFromSphericalCoords(1, phi, Math.PI);
        sky.material.uniforms['sunPosition'].value.copy(sun);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(100, 100, 100);
        light.castShadow = true;
        light.shadow.mapSize.set(2048, 2048);
        scene.add(light);

        water = new Water(new THREE.PlaneGeometry(5000, 5000), {
            textureWidth: 512, textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', t => t.wrapS = t.wrapT = THREE.RepeatWrapping),
            sunDirection: sun, sunColor: 0xffffff, waterColor: 0x002a3a, distortionScale: 3.7
        });
        water.rotation.x = -Math.PI / 2;
        water.position.y = 0.4;
        scene.add(water);
    }

    function createRealisticIsland() {
        // Ландшафт на основе сложной формы (как реальный остров)
        const islandGeo = new THREE.PlaneGeometry(150, 150, 100, 100);
        const pos = islandGeo.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            let x = pos.getX(i), y = pos.getY(i);
            // Форма "песочных часов" / гантели
            let islandShape = (Math.pow(x, 2) / 1600 + Math.pow(y, 2) / 4500) < 1.0 || 
                              (Math.pow(x-40, 2)/800 + Math.pow(y-40, 2)/800) < 0.8;
            
            let dist = Math.sqrt(x*x + y*y);
            let height = 0;
            if (dist < 50) height = Math.pow(Math.cos(dist/30), 2) * 12; // Центральный холм
            
            if (dist > 65 && !islandShape) height = -5; // Уходит под воду
            else height += Math.sin(x*0.1) * Math.cos(y*0.1) * 2; // Шум рельефа

            pos.setZ(i, Math.max(-2, height));
        }
        islandGeo.computeVertexNormals();
        const island = new THREE.Mesh(islandGeo, new THREE.MeshStandardMaterial({ color: 0xc2b280, roughness: 1 }));
        island.rotation.x = -Math.PI / 2;
        island.receiveShadow = true;
        scene.add(island);

        // Храм (Синий с белым + купол)
        createTemple(0, 11, 0);

        // Растительность
        for(let i = 0; i < 40; i++) {
            let a = Math.random() * Math.PI * 2;
            let r = 20 + Math.random() * 40;
            createPalm(Math.cos(a)*r, Math.sin(a)*r);
        }
    }

    function createTemple(x, y, z) {
        const group = new THREE.Group();
        for(let i = 0; i < 18; i++) {
            const stripe = new THREE.Mesh(
                new THREE.BoxGeometry(10, 0.4, 10),
                new THREE.MeshStandardMaterial({ color: i%2===0?0xffffff:0x0047ab, roughness: 0.3 })
            );
            stripe.position.y = i * 0.4;
            stripe.castShadow = true;
            group.add(stripe);
        }
        const dome = new THREE.Mesh(new THREE.SphereGeometry(4, 32, 16, 0, 6.3, 0, 1.6), new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 0.8, roughness: 0.2}));
        dome.position.y = 7;
        group.add(dome);
        group.position.set(x, y, z);
        scene.add(group);
        colliders.push({ pos: new THREE.Vector3(x, 0, z), radius: 6 });
    }

    function createPalm(x, z) {
        const h = 5 + Math.random() * 4;
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, h), new THREE.MeshStandardMaterial({color: 0x5d4037}));
        trunk.position.set(x, h/2 + 2, z);
        trunk.castShadow = true;
        scene.add(trunk);
        
        // Листья
        for(let i = 0; i < 8; i++) {
            const leaf = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 2), new THREE.MeshStandardMaterial({color: 0x2e7d32}));
            leaf.scale.set(1.5, 0.05, 0.4);
            leaf.position.set(x, h + 2, z);
            leaf.rotation.y = i;
            leaf.rotation.z = 0.4;
            scene.add(leaf);
        }
        colliders.push({ pos: new THREE.Vector3(x, 0, z), radius: 1.5 });
    }

    function setupControls() {
        const stick = document.getElementById('joystick-stick');
        const wrapper = document.getElementById('joystick-wrapper');
        
        const handleMove = (e) => {
            const touch = e.touches[0];
            const rect = wrapper.getBoundingClientRect();
            const dx = touch.clientX - (rect.left + 60);
            const dy = touch.clientY - (rect.top + 60);
            const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 40);
            const angle = Math.atan2(dy, dx);
            
            stick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
            moveDir.x = Math.cos(angle) * (dist/40);
            moveDir.y = Math.sin(angle) * (dist/40);
        };

        wrapper.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e); }, {passive: false});
        wrapper.addEventListener('touchend', () => {
            stick.style.transform = 'none';
            moveDir = { x: 0, y: 0 };
        });

        // Обзор правой частью экрана
        window.addEventListener('touchmove', e => {
            if(e.touches[0].clientX > window.innerWidth/2) {
                lookYaw -= e.touches[0].radiusX * 0.01 || 0.05; // Упрощенно
                // Для мобильных лучше использовать накопление дельты
            }
        });
        
        // Для ПК
        window.addEventListener('mousemove', e => {
            if(document.pointerLockElement) {
                lookYaw -= e.movementX * 0.002;
                lookPitch -= e.movementY * 0.002;
            }
        });
        window.addEventListener('click', () => document.body.requestPointerLock());
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();

        // Поворот камеры
        lookPitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, lookPitch));
        camera.rotation.set(lookPitch, lookYaw, 0);

        // Движение с проверкой коллизий
        const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        dir.y = 0; dir.normalize();
        const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

        const nextPos = camera.position.clone();
        nextPos.addScaledVector(dir, -moveDir.y * dt * 15);
        nextPos.addScaledVector(side, moveDir.x * dt * 15);

        // Проверка столкновений
        let canMove = true;
        colliders.forEach(c => {
            const d = Math.sqrt(Math.pow(nextPos.x - c.pos.x, 2) + Math.pow(nextPos.z - c.pos.z, 2));
            if(d < c.radius) canMove = false;
        });

        if(canMove) {
            camera.position.copy(nextPos);
        }

        // Удержание на ландшафте (упрощенно)
        camera.position.y = 2 + Math.max(0.5, (30 - Math.sqrt(camera.position.x**2 + camera.position.z**2))*0.2);

        water.material.uniforms['time'].value += dt;
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>

