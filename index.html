<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>St. James: Ultra Realistic First Person</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; cursor: crosshair; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            border: 1px solid rgba(255,255,255,0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #ui { position: absolute; bottom: 20px; left: 20px; color: white; text-shadow: 2px 2px 4px #000; pointer-events: none; }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="ui">Кликните, чтобы войти в режим 1-го лица (WASD + Мышь)</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { Water } from 'three/addons/objects/Water.js';
    import { Sky } from 'three/addons/objects/Sky.js';

    let scene, camera, renderer, controls, water, clock;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();

    init();

    function init() {
        scene = new THREE.Scene();
        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(30, 1.7, 30); // Рост человека

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        document.body.appendChild(renderer.domElement);

        // Управление 1-го лица
        controls = new PointerLockControls(camera, document.body);
        document.body.addEventListener('click', () => controls.lock());

        setupLighting();
        setupEnvironment();
        createDetailedIsland();
        
        // Пальмы (расставляем по острову)
        for(let i = 0; i < 25; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 30;
            createRealisticPalm(Math.cos(angle)*dist, Math.sin(angle)*dist);
        }

        setupInput();
        animate();
    }

    function setupLighting() {
        const sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);

        const sun = new THREE.Vector3();
        const phi = THREE.MathUtils.degToRad(85);
        const theta = THREE.MathUtils.degToRad(180);
        sun.setFromSphericalCoords(1, phi, theta);
        sky.material.uniforms['sunPosition'].value.copy(sun);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.copy(sun).multiplyScalar(100);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.set(2048, 2048);
        scene.add(directionalLight);
    }

    function setupEnvironment() {
        const waterGeo = new THREE.PlaneGeometry(10000, 10000);
        water = new Water(waterGeo, {
            textureWidth: 1024, textureHeight: 1024,
            waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', t => t.wrapS = t.wrapT = THREE.RepeatWrapping),
            sunDirection: new THREE.Vector3(),
            sunColor: 0xffffff,
            waterColor: 0x001e0f,
            distortionScale: 3.7,
        });
        water.rotation.x = -Math.PI / 2;
        scene.add(water);
    }

    function createRealisticPalm(x, z) {
        const palmGroup = new THREE.Group();
        
        // Ствол (изогнутый)
        const points = [];
        for (let i = 0; i < 10; i++) {
            points.push(new THREE.Vector3(Math.sin(i * 0.2) * 0.5, i * 0.8, 0));
        }
        const trunkGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 20, 0.2, 8, false);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.castShadow = true;
        palmGroup.add(trunk);

        // Листья (пышные)
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32, side: THREE.DoubleSide, roughness: 0.6 });
        for (let i = 0; i < 12; i++) {
            const leafGeo = new THREE.SphereGeometry(2, 8, 2);
            leafGeo.scale(1.5, 0.05, 0.4);
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.position.y = 7.2;
            leaf.rotation.y = (i * Math.PI * 2) / 12;
            leaf.rotation.z = 0.4;
            palmGroup.add(leaf);
        }

        palmGroup.position.set(x, -0.5, z);
        scene.add(palmGroup);
    }

    function createDetailedIsland() {
        // Здание (на возвышенности)
        const temple = new THREE.Group();
        for(let i = 0; i < 20; i++) {
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(12, 0.4, 12),
                new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? 0xffffff : 0x0044ff, roughness: 0.2 })
            );
            box.position.y = i * 0.4;
            box.castShadow = true;
            temple.add(box);
        }
        const dome = new THREE.Mesh(
            new THREE.SphereGeometry(4.5, 32, 32, 0, Math.PI*2, 0, Math.PI/2),
            new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1, roughness: 0.1 })
        );
        dome.position.y = 8;
        temple.add(dome);
        scene.add(temple);

        // Песок
        const islandGeo = new THREE.CylinderGeometry(60, 70, 4, 64);
        const islandMat = new THREE.MeshStandardMaterial({ color: 0xe3c1a1, roughness: 1 });
        const island = new THREE.Mesh(islandGeo, islandMat);
        island.position.y = -2;
        island.receiveShadow = true;
        scene.add(island);
    }

    function setupInput() {
        const onKeyDown = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
            }
        };
        const onKeyUp = (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        };
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        if (controls.isLocked) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 150.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 150.0 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
        }

        water.material.uniforms['time'].value += delta;
        renderer.render(scene, camera);
    }
</script>
</body>
</html>

