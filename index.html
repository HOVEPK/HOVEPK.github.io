<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Temple Pro: Fixed & Smashed</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; -webkit-user-select: none; }
        canvas { display: block; touch-action: none; }
        
        #joy-base {
            position: absolute; width: 120px; height: 120px;
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%; display: none; z-index: 100; backdrop-filter: blur(10px);
            pointer-events: none; /* Щоб не заважало тачам */
        }
        #joy-stick {
            position: absolute; width: 50px; height: 50px;
            background: #fff; border-radius: 50%; top: 35px; left: 35px;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="joy-base"><div id="joy-stick"></div></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { Water } from 'three/addons/objects/Water.js';

        // --- ENGINE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(40, 2, 40);
        camera.rotation.order = 'YXZ';

        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        scene.add(new THREE.HemisphereLight(0x87CEEB, 0x444444, 1.2));
        const sunPos = new THREE.Vector3();
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);

        // --- SKY & WATER ---
        const sky = new Sky(); sky.scale.setScalar(10000); scene.add(sky);
        sunPos.setFromSphericalCoords(1, THREE.MathUtils.degToRad(85), THREE.MathUtils.degToRad(180));
        sky.material.uniforms['sunPosition'].value.copy(sunPos);
        dirLight.position.copy(sunPos).multiplyScalar(100);

        const water = new Water(new THREE.PlaneGeometry(5000, 5000), {
            textureWidth: 512, textureHeight: 512,
            waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', t => t.wrapS = t.wrapT = THREE.RepeatWrapping),
            sunDirection: sunPos, sunColor: 0xffffff, waterColor: 0x001e0f, distortionScale: 3.0
        });
        water.rotation.x = -Math.PI / 2; water.position.y = -1; scene.add(water);

        // --- ISLAND ---
        const island = new THREE.Mesh(
            new THREE.CylinderGeometry(80, 85, 10, 64),
            new THREE.MeshStandardMaterial({ color: 0xeed2af, roughness: 1 })
        );
        island.position.y = -5.5; island.receiveShadow = true; scene.add(island);

        // --- SMASHED TEMPLE ---
        const temple = new THREE.Group();
        const wallH = 12; const wallW = 16;
        for (let i = 0; i < 15; i++) {
            const h = wallH / 15; const y = i * h + h/2; const blue = i % 2 === 0;
            const mat = new THREE.MeshStandardMaterial({ color: blue ? 0x0044ff : 0xffffff });
            
            const back = new THREE.Mesh(new THREE.BoxGeometry(wallW, h, 0.8), mat);
            back.position.set(0, y, -wallW/2); temple.add(back);

            const lSide = new THREE.Mesh(new THREE.BoxGeometry(0.8, h, wallW), mat);
            lSide.position.set(-wallW/2, y, 0); temple.add(lSide);

            const rSide = new THREE.Mesh(new THREE.BoxGeometry(0.8, h, wallW), mat);
            rSide.position.set(wallW/2, y, 0); temple.add(rSide);

            if (i > 10) { // Стіна над розбитими дверима
                const frontTop = new THREE.Mesh(new THREE.BoxGeometry(wallW, h, 0.8), mat);
                frontTop.position.set(0, y, wallW/2); temple.add(frontTop);
            } else { // Боковини входу
                const fL = new THREE.Mesh(new THREE.BoxGeometry(6, h, 0.8), mat);
                fL.position.set(-5, y, wallW/2); temple.add(fL);
                const fR = new THREE.Mesh(new THREE.BoxGeometry(6, h, 0.8), mat);
                fR.position.set(5, y, wallW/2); temple.add(fR);
            }
        }
        const dome = new THREE.Mesh(new THREE.SphereGeometry(8, 32, 16, 0, Math.PI*2, 0, Math.PI/2), new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 1, roughness: 0.1}));
        dome.position.y = wallH; temple.add(dome);
        scene.add(temple);

        // --- OPTIMIZED CONTROLS ---
        let joyId = null, lookId = null;
        let move = { x: 0, y: 0, startX: 0, startY: 0 };
        let rot = { yaw: camera.rotation.y, pitch: 0 };
        let lastLook = { x: 0, y: 0 };
        const joyB = document.getElementById('joy-base'), joyS = document.getElementById('joy-stick');

        const onTouchStart = (e) => {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.clientX < window.innerWidth / 2 && joyId === null) {
                    joyId = t.identifier;
                    move.startX = t.clientX; move.startY = t.clientY;
                    joyB.style.display = 'block';
                    joyB.style.left = (t.clientX - 60) + 'px';
                    joyB.style.top = (t.clientY - 60) + 'px';
                } else if (lookId === null) {
                    lookId = t.identifier;
                    lastLook.x = t.clientX; lastLook.y = t.clientY;
                }
            }
        };

        const onTouchMove = (e) => {
            e.preventDefault();
            for (let t of e.changedTouches) {
                if (t.identifier === joyId) {
                    let dx = t.clientX - move.startX, dy = t.clientY - move.startY;
                    let d = Math.min(Math.sqrt(dx*dx + dy*dy), 45);
                    let a = Math.atan2(dy, dx);
                    move.x = Math.cos(a) * (d / 45); move.y = Math.sin(a) * (d / 45);
                    joyS.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
                } else if (t.identifier === lookId) {
                    rot.yaw -= (t.clientX - lastLook.x) * 0.006;
                    rot.pitch -= (t.clientY - lastLook.y) * 0.006;
                    rot.pitch = Math.max(-1.4, Math.min(1.4, rot.pitch));
                    lastLook.x = t.clientX; lastLook.y = t.clientY;
                }
            }
        };

        const onTouchEnd = (e) => {
            for (let t of e.changedTouches) {
                if (t.identifier === joyId) {
                    joyId = null; move.x = 0; move.y = 0; joyB.style.display = 'none';
                } else if (t.identifier === lookId) {
                    lookId = null;
                }
            }
        };

        window.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });
        window.addEventListener('touchend', onTouchEnd);

        // --- LOOP & COLLISION ---
        function animate() {
            requestAnimationFrame(animate);
            if (joyId !== null) {
                const f = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); f.y = 0; f.normalize();
                const r = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); r.y = 0; r.normalize();
                const old = camera.position.clone();
                camera.position.addScaledVector(f, -move.y * 0.3);
                camera.position.addScaledVector(r, move.x * 0.3);

                // COLLISION LOGIC
                const dist = 7.5; 
                // Стіни (зовні та всередині)
                if (Math.abs(camera.position.x) > dist || camera.position.z < -dist) {
                    if (!(camera.position.z > dist)) camera.position.copy(old);
                }
                // Передній вхід (Smash zone)
                if (camera.position.z > dist) {
                    if (Math.abs(camera.position.x) > 2) camera.position.copy(old); // Прохід шириною 4 метри
                }
                // Острів
                if (camera.position.length() > 75) camera.position.copy(old);
            }
            camera.rotation.y = rot.yaw; camera.rotation.x = rot.pitch;
            water.material.uniforms['time'].value += 1.0 / 60.0;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>

