<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Private Island 3D</title>
    <style>
      html, body { margin: 0; overflow: hidden; height: 100%; }
      canvas { display: block; width: 100%; height: 100%; }
      #joystick {
        position: absolute;
        bottom: 30px; left: 30px;
        width: 100px; height: 100px;
        border-radius: 50%;
        background: rgba(255,255,255,0.1);
        border: 2px solid #fff;
        touch-action: none;
      }
      #stick {
        position: absolute;
        left: 35px; top: 35px;
        width: 30px; height: 30px;
        border-radius: 50%;
        background: rgba(255,255,255,0.7);
      }
    </style>
  </head>
  <body>
    <div id="joystick"><div id="stick"></div></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

    <script>
      // === Параметры сцены ===
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // === Свет и земля ===
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x888888));

      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshLambertMaterial({color: 0x228B22});
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // === Модель простого "храма" ===
      const temple = new THREE.Group();
      const bodyGeo = new THREE.BoxGeometry(10, 10, 10);
      const stripes = new THREE.MeshLambertMaterial({color: 0x1E90FF});
      const stripes2 = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
      const materials = [stripes, stripes2];

      const body = new THREE.Mesh(bodyGeo, new THREE.MeshLambertMaterial({color: 0xffffff}));
      temple.add(body);

      // Купол
      const domeGeo = new THREE.SphereGeometry(5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
      const domeMat = new THREE.MeshLambertMaterial({color: 0xFFD700});
      const dome = new THREE.Mesh(domeGeo, domeMat);
      dome.position.y = 5;
      temple.add(dome);

      temple.position.set(0, 5, -30);
      scene.add(temple);

      // === Позиция камеры ===
      camera.position.set(0, 2, 0);
      let velocity = new THREE.Vector3();

      // === Сенсорный джойстик ===
      const joystick = document.getElementById('joystick');
      const stick = document.getElementById('stick');
      let joyActive = false, joyStartX, joyStartY, joyDX = 0, joyDY = 0;

      joystick.addEventListener('touchstart', e => {
        const t = e.touches[0];
        joyActive = true;
        joyStartX = t.clientX; joyStartY = t.clientY;
      });

      joystick.addEventListener('touchmove', e => {
        const t = e.touches[0];
        joyDX = (t.clientX - joyStartX) / 40;
        joyDY = (t.clientY - joyStartY) / 40;
        const max = 1;
        joyDX = Math.min(Math.max(joyDX, -max), max);
        joyDY = Math.min(Math.max(joyDY, -max), max);
        stick.style.left = 35 + joyDX * 20 + "px";
        stick.style.top = 35 + joyDY * 20 + "px";
      });

      joystick.addEventListener('touchend', () => {
        joyActive = false; joyDX = 0; joyDY = 0;
        stick.style.left = "35px"; stick.style.top = "35px";
      });

      // === Управление камерой ===
      let yaw = 0;
      window.addEventListener('deviceorientation', (e) => {
        if (e.alpha != null) yaw = THREE.MathUtils.degToRad(e.alpha);
      });

      function animate() {
        requestAnimationFrame(animate);
        // Перемещение
        velocity.x = Math.sin(yaw) * joyDY + Math.cos(yaw) * joyDX;
        velocity.z = Math.cos(yaw) * joyDY - Math.sin(yaw) * joyDX;
        camera.position.x += velocity.x * 0.3;
        camera.position.z += velocity.z * 0.3;

        camera.lookAt(camera.position.x + Math.sin(yaw), camera.position.y, camera.position.z - Math.cos(yaw));

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
